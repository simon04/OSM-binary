// Code generated by Wire protocol buffer compiler, do not edit.
// Source: OSMPBF.HeaderBlock in osmformat.proto
package crosby.binary.wire;

import com.squareup.wire.FieldEncoding;
import com.squareup.wire.Message;
import com.squareup.wire.ProtoAdapter;
import com.squareup.wire.ProtoReader;
import com.squareup.wire.ProtoWriter;
import com.squareup.wire.Syntax;
import com.squareup.wire.WireField;
import com.squareup.wire.internal.Internal;
import java.io.IOException;
import java.lang.Long;
import java.lang.Object;
import java.lang.Override;
import java.lang.String;
import java.lang.StringBuilder;
import java.util.List;
import okio.ByteString;

/**
 * OSM Binary file format
 *
 * This is the master schema file of the OSM binary file format. This
 * file is designed to support limited random-access and future
 * extendability.
 *
 * A binary OSM file consists of a sequence of FileBlocks (please see
 * fileformat.proto). The first fileblock contains a serialized instance
 * of HeaderBlock, followed by a sequence of PrimitiveBlock blocks that
 * contain the primitives.
 *
 * Each primitiveblock is designed to be independently parsable. It
 * contains a string table storing all strings in that block (keys and
 * values in tags, roles in relations, usernames, etc.) as well as
 * metadata containing the precision of coordinates or timestamps in that
 * block.
 *
 * A primitiveblock contains a sequence of primitive groups, each
 * containing primitives of the same type (nodes, densenodes, ways,
 * relations). Coordinates are stored in signed 64-bit integers. Lat&lon
 * are measured in units <granularity> nanodegrees. The default of
 * granularity of 100 nanodegrees corresponds to about 1cm on the ground,
 * and a full lat or lon fits into 32 bits.
 *
 * Converting an integer to a latitude or longitude uses the formula:
 * $OUT = IN * granularity / 10**9$. Many encoding schemes use delta
 * coding when representing nodes and relations.
 * ////////////////////////////////////////////////////////////////////////
 * ////////////////////////////////////////////////////////////////////////
 * Contains the file header.
 */
public final class HeaderBlock extends Message<HeaderBlock, HeaderBlock.Builder> {
  public static final ProtoAdapter<HeaderBlock> ADAPTER = new ProtoAdapter_HeaderBlock();

  private static final long serialVersionUID = 0L;

  public static final String DEFAULT_WRITINGPROGRAM = "";

  public static final String DEFAULT_SOURCE = "";

  public static final Long DEFAULT_OSMOSIS_REPLICATION_TIMESTAMP = 0L;

  public static final Long DEFAULT_OSMOSIS_REPLICATION_SEQUENCE_NUMBER = 0L;

  public static final String DEFAULT_OSMOSIS_REPLICATION_BASE_URL = "";

  @WireField(
      tag = 1,
      adapter = "crosby.binary.wire.HeaderBBox#ADAPTER"
  )
  public final HeaderBBox bbox;

  /**
   * Additional tags to aid in parsing this dataset
   */
  @WireField(
      tag = 4,
      adapter = "com.squareup.wire.ProtoAdapter#STRING",
      label = WireField.Label.REPEATED
  )
  public final List<String> required_features;

  @WireField(
      tag = 5,
      adapter = "com.squareup.wire.ProtoAdapter#STRING",
      label = WireField.Label.REPEATED
  )
  public final List<String> optional_features;

  @WireField(
      tag = 16,
      adapter = "com.squareup.wire.ProtoAdapter#STRING"
  )
  public final String writingprogram;

  /**
   * From the bbox field.
   */
  @WireField(
      tag = 17,
      adapter = "com.squareup.wire.ProtoAdapter#STRING"
  )
  public final String source;

  /**
   * Tags that allow continuing an Osmosis replication
   * Replication timestamp, expressed in seconds since the epoch,
   * otherwise the same value as in the "timestamp=..." field
   * in the state.txt file used by Osmosis.
   */
  @WireField(
      tag = 32,
      adapter = "com.squareup.wire.ProtoAdapter#INT64"
  )
  public final Long osmosis_replication_timestamp;

  /**
   * Replication sequence number (sequenceNumber in state.txt).
   */
  @WireField(
      tag = 33,
      adapter = "com.squareup.wire.ProtoAdapter#INT64"
  )
  public final Long osmosis_replication_sequence_number;

  /**
   * Replication base URL (from Osmosis' configuration.txt file).
   */
  @WireField(
      tag = 34,
      adapter = "com.squareup.wire.ProtoAdapter#STRING"
  )
  public final String osmosis_replication_base_url;

  public HeaderBlock(HeaderBBox bbox, List<String> required_features,
      List<String> optional_features, String writingprogram, String source,
      Long osmosis_replication_timestamp, Long osmosis_replication_sequence_number,
      String osmosis_replication_base_url) {
    this(bbox, required_features, optional_features, writingprogram, source, osmosis_replication_timestamp, osmosis_replication_sequence_number, osmosis_replication_base_url, ByteString.EMPTY);
  }

  public HeaderBlock(HeaderBBox bbox, List<String> required_features,
      List<String> optional_features, String writingprogram, String source,
      Long osmosis_replication_timestamp, Long osmosis_replication_sequence_number,
      String osmosis_replication_base_url, ByteString unknownFields) {
    super(ADAPTER, unknownFields);
    this.bbox = bbox;
    this.required_features = Internal.immutableCopyOf("required_features", required_features);
    this.optional_features = Internal.immutableCopyOf("optional_features", optional_features);
    this.writingprogram = writingprogram;
    this.source = source;
    this.osmosis_replication_timestamp = osmosis_replication_timestamp;
    this.osmosis_replication_sequence_number = osmosis_replication_sequence_number;
    this.osmosis_replication_base_url = osmosis_replication_base_url;
  }

  @Override
  public Builder newBuilder() {
    Builder builder = new Builder();
    builder.bbox = bbox;
    builder.required_features = Internal.copyOf(required_features);
    builder.optional_features = Internal.copyOf(optional_features);
    builder.writingprogram = writingprogram;
    builder.source = source;
    builder.osmosis_replication_timestamp = osmosis_replication_timestamp;
    builder.osmosis_replication_sequence_number = osmosis_replication_sequence_number;
    builder.osmosis_replication_base_url = osmosis_replication_base_url;
    builder.addUnknownFields(unknownFields());
    return builder;
  }

  @Override
  public boolean equals(Object other) {
    if (other == this) return true;
    if (!(other instanceof HeaderBlock)) return false;
    HeaderBlock o = (HeaderBlock) other;
    return unknownFields().equals(o.unknownFields())
        && Internal.equals(bbox, o.bbox)
        && required_features.equals(o.required_features)
        && optional_features.equals(o.optional_features)
        && Internal.equals(writingprogram, o.writingprogram)
        && Internal.equals(source, o.source)
        && Internal.equals(osmosis_replication_timestamp, o.osmosis_replication_timestamp)
        && Internal.equals(osmosis_replication_sequence_number, o.osmosis_replication_sequence_number)
        && Internal.equals(osmosis_replication_base_url, o.osmosis_replication_base_url);
  }

  @Override
  public int hashCode() {
    int result = super.hashCode;
    if (result == 0) {
      result = unknownFields().hashCode();
      result = result * 37 + (bbox != null ? bbox.hashCode() : 0);
      result = result * 37 + required_features.hashCode();
      result = result * 37 + optional_features.hashCode();
      result = result * 37 + (writingprogram != null ? writingprogram.hashCode() : 0);
      result = result * 37 + (source != null ? source.hashCode() : 0);
      result = result * 37 + (osmosis_replication_timestamp != null ? osmosis_replication_timestamp.hashCode() : 0);
      result = result * 37 + (osmosis_replication_sequence_number != null ? osmosis_replication_sequence_number.hashCode() : 0);
      result = result * 37 + (osmosis_replication_base_url != null ? osmosis_replication_base_url.hashCode() : 0);
      super.hashCode = result;
    }
    return result;
  }

  @Override
  public String toString() {
    StringBuilder builder = new StringBuilder();
    if (bbox != null) builder.append(", bbox=").append(bbox);
    if (!required_features.isEmpty()) builder.append(", required_features=").append(Internal.sanitize(required_features));
    if (!optional_features.isEmpty()) builder.append(", optional_features=").append(Internal.sanitize(optional_features));
    if (writingprogram != null) builder.append(", writingprogram=").append(Internal.sanitize(writingprogram));
    if (source != null) builder.append(", source=").append(Internal.sanitize(source));
    if (osmosis_replication_timestamp != null) builder.append(", osmosis_replication_timestamp=").append(osmosis_replication_timestamp);
    if (osmosis_replication_sequence_number != null) builder.append(", osmosis_replication_sequence_number=").append(osmosis_replication_sequence_number);
    if (osmosis_replication_base_url != null) builder.append(", osmosis_replication_base_url=").append(Internal.sanitize(osmosis_replication_base_url));
    return builder.replace(0, 2, "HeaderBlock{").append('}').toString();
  }

  public static final class Builder extends Message.Builder<HeaderBlock, Builder> {
    public HeaderBBox bbox;

    public List<String> required_features;

    public List<String> optional_features;

    public String writingprogram;

    public String source;

    public Long osmosis_replication_timestamp;

    public Long osmosis_replication_sequence_number;

    public String osmosis_replication_base_url;

    public Builder() {
      required_features = Internal.newMutableList();
      optional_features = Internal.newMutableList();
    }

    public Builder bbox(HeaderBBox bbox) {
      this.bbox = bbox;
      return this;
    }

    /**
     * Additional tags to aid in parsing this dataset
     */
    public Builder required_features(List<String> required_features) {
      Internal.checkElementsNotNull(required_features);
      this.required_features = required_features;
      return this;
    }

    public Builder optional_features(List<String> optional_features) {
      Internal.checkElementsNotNull(optional_features);
      this.optional_features = optional_features;
      return this;
    }

    public Builder writingprogram(String writingprogram) {
      this.writingprogram = writingprogram;
      return this;
    }

    /**
     * From the bbox field.
     */
    public Builder source(String source) {
      this.source = source;
      return this;
    }

    /**
     * Tags that allow continuing an Osmosis replication
     * Replication timestamp, expressed in seconds since the epoch,
     * otherwise the same value as in the "timestamp=..." field
     * in the state.txt file used by Osmosis.
     */
    public Builder osmosis_replication_timestamp(Long osmosis_replication_timestamp) {
      this.osmosis_replication_timestamp = osmosis_replication_timestamp;
      return this;
    }

    /**
     * Replication sequence number (sequenceNumber in state.txt).
     */
    public Builder osmosis_replication_sequence_number(Long osmosis_replication_sequence_number) {
      this.osmosis_replication_sequence_number = osmosis_replication_sequence_number;
      return this;
    }

    /**
     * Replication base URL (from Osmosis' configuration.txt file).
     */
    public Builder osmosis_replication_base_url(String osmosis_replication_base_url) {
      this.osmosis_replication_base_url = osmosis_replication_base_url;
      return this;
    }

    @Override
    public HeaderBlock build() {
      return new HeaderBlock(bbox, required_features, optional_features, writingprogram, source, osmosis_replication_timestamp, osmosis_replication_sequence_number, osmosis_replication_base_url, super.buildUnknownFields());
    }
  }

  private static final class ProtoAdapter_HeaderBlock extends ProtoAdapter<HeaderBlock> {
    public ProtoAdapter_HeaderBlock() {
      super(FieldEncoding.LENGTH_DELIMITED, HeaderBlock.class, "type.googleapis.com/OSMPBF.HeaderBlock", Syntax.PROTO_2, null);
    }

    @Override
    public int encodedSize(HeaderBlock value) {
      int result = 0;
      result += HeaderBBox.ADAPTER.encodedSizeWithTag(1, value.bbox);
      result += ProtoAdapter.STRING.asRepeated().encodedSizeWithTag(4, value.required_features);
      result += ProtoAdapter.STRING.asRepeated().encodedSizeWithTag(5, value.optional_features);
      result += ProtoAdapter.STRING.encodedSizeWithTag(16, value.writingprogram);
      result += ProtoAdapter.STRING.encodedSizeWithTag(17, value.source);
      result += ProtoAdapter.INT64.encodedSizeWithTag(32, value.osmosis_replication_timestamp);
      result += ProtoAdapter.INT64.encodedSizeWithTag(33, value.osmosis_replication_sequence_number);
      result += ProtoAdapter.STRING.encodedSizeWithTag(34, value.osmosis_replication_base_url);
      result += value.unknownFields().size();
      return result;
    }

    @Override
    public void encode(ProtoWriter writer, HeaderBlock value) throws IOException {
      HeaderBBox.ADAPTER.encodeWithTag(writer, 1, value.bbox);
      ProtoAdapter.STRING.asRepeated().encodeWithTag(writer, 4, value.required_features);
      ProtoAdapter.STRING.asRepeated().encodeWithTag(writer, 5, value.optional_features);
      ProtoAdapter.STRING.encodeWithTag(writer, 16, value.writingprogram);
      ProtoAdapter.STRING.encodeWithTag(writer, 17, value.source);
      ProtoAdapter.INT64.encodeWithTag(writer, 32, value.osmosis_replication_timestamp);
      ProtoAdapter.INT64.encodeWithTag(writer, 33, value.osmosis_replication_sequence_number);
      ProtoAdapter.STRING.encodeWithTag(writer, 34, value.osmosis_replication_base_url);
      writer.writeBytes(value.unknownFields());
    }

    @Override
    public HeaderBlock decode(ProtoReader reader) throws IOException {
      Builder builder = new Builder();
      long token = reader.beginMessage();
      for (int tag; (tag = reader.nextTag()) != -1;) {
        switch (tag) {
          case 1: builder.bbox(HeaderBBox.ADAPTER.decode(reader)); break;
          case 4: builder.required_features.add(ProtoAdapter.STRING.decode(reader)); break;
          case 5: builder.optional_features.add(ProtoAdapter.STRING.decode(reader)); break;
          case 16: builder.writingprogram(ProtoAdapter.STRING.decode(reader)); break;
          case 17: builder.source(ProtoAdapter.STRING.decode(reader)); break;
          case 32: builder.osmosis_replication_timestamp(ProtoAdapter.INT64.decode(reader)); break;
          case 33: builder.osmosis_replication_sequence_number(ProtoAdapter.INT64.decode(reader)); break;
          case 34: builder.osmosis_replication_base_url(ProtoAdapter.STRING.decode(reader)); break;
          default: {
            reader.readUnknownField(tag);
          }
        }
      }
      builder.addUnknownFields(reader.endMessageAndGetUnknownFields(token));
      return builder.build();
    }

    @Override
    public HeaderBlock redact(HeaderBlock value) {
      Builder builder = value.newBuilder();
      if (builder.bbox != null) builder.bbox = HeaderBBox.ADAPTER.redact(builder.bbox);
      builder.clearUnknownFields();
      return builder.build();
    }
  }
}
